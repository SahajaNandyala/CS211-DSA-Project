/*SRI RAMA*/
#include<stdio.h>
#include<stdlib.h>

struct tree
{
    int x,y,h,d,c,p;
    int value,weight,profit,direc;
}*tree_prop;
int time_limit,grid_size,no_of_trees;
int c_x=0, c_y=0,px=0,py=0;
int temp[100],track[100],iterator=0,iterator1=0;
void pushBack(int data,) {
  /* code */
}
void calculate_profit();
int main()
{
  //struct tree *tree_prop;
	//int time_limit,grid_size,no_of_trees;
	int i;
	scanf("%d%d%d",&time_limit,&grid_size,&no_of_trees);
	tree_prop=(struct tree*)malloc(no_of_trees*sizeof(struct tree));
	for(i=0;i<no_of_trees;i++)
	{
		scanf("%d %d %d %d %d %d",&tree_prop[i].x,&tree_prop[i].y,&tree_prop[i].h,&tree_prop[i].d,&tree_prop[i].c,&tree_prop[i].p);
    tree_prop[i].value=tree_prop[i].p*tree_prop[i].h*tree_prop[i].d;
		tree_prop[i].weight=tree_prop[i].c*tree_prop[i].d*tree_prop[i].h;
    v[i].profit= v[i].value;
		v[i].direc=0;
	}
  int total_p=0,m,pos,i,total;
	m=abs(tree_prop[0].x)+abs(tree_prop[0].y);
  pos=0;
  for(i=0;i<no_of_trees;i++){
          if((abs(tree_prop[i].x)+abs(tree_prop[i].y))<m){
          m=abs(tree_prop[i].x)+abs(tree_prop[i].y);
          pos=i;
          }
  }
  if(tree_prop[pos].x+tree_prop[pos].y+tree_prop[pos].d<=t){
      total_p=total_p+tree_prop[pos].value;
  }
	return 0;
}
void calculate_profit()
{
  for (int i=0; i<no_of_trees; i++)
  {
    int cost= abs(tree_prop[i].x-c_x) + abs(tree_prop[i].y-c_y) + tree_prop[i].d;
    if (cost <= time_limit) {
      int upProfit=0, rightProfit=0, downProfit=0, leftProfit=0;
      int dprofit=0;
      upProfit= cutup_profit(i);
      for(iterator1=0;iterator1<iterator;iterator1++)
      track[j] = temp[j];
			dprofit= upProfit;
      iterator=0;
      rightProfit= cutright_profit(i);
			if (rightProfit > dprofit)
      {
				dprofit= rightProfit;
        iterator1=0;
        for(iterator1=0;iterator1<iterator;iterator1++)
        {
				track[iterator1]= temp[iterator1];
        }
  			tree_prop[i].direc= 1;
      }
      iterator=0;
      downprofit=cutdown_profit(i);
      if (downProfit > dprofit) {
				dprofit= downProfit;
				iterator1=0;
        for(iterator1=0;iterator1<iterator;iterator1++)
        {
				track[iterator1]= temp[iterator1];
        }
				tree_prop[i].direc=2;
        iterator=0;
  			leftProfit= cutleft_profit(i);
  			if (leftProfit > dprofit) {
  				dprofit= leftProfit;
  				iterator1=0;
          for(iterator1=0;iterator1<iterator;iterator1++)
          {
  				track[iterator1]= temp[iterator1];
          }
  				tree_prop[i].direc=3;
  			}
  			tree_prop[i].profit += dprofit;
  			//v[i].track= track;
			}
  }
}
int cutup_profit(int a) {
	int profit=0;
	int min=-1;
	int i;
	for (i=0; i<no_of_trees; i++) {
		if (tree_prop[i].x == tree_prop[a].x && tree_prop[i].y > tree_prop[a].y) {
			min = i;
			break;
		}
	}
  int j;
	for (j=i+1; j<no_of_trees; j++) {
		if (tree_prop[j].x == tree_prop[a].x && tree_prop[j].y > tree_prop[a].y && tree_prop[j].y < tree_prop[min].y) {
			min = j;
		}
	}
	if (min >0) {
		if (tree_prop[a].weight > tree_prop[min].weight && tree_prop[a].h > tree_prop[min].y-tree_prop[a].y) {
			profit= tree_prop[min].value;
			temp[iterator]=min;
      iterator++;
			int temp1= cutup_profit(min);
			profit= profit + temp1;
			return profit;
		}
		else {
			return 0;
		}
	}
	else {
		return 0;
	}
}
int cutright_profit(int a) {
	int profit=0;
	int min=-1;
	int i;
	for (i=0; i<no_of_trees; i++) {
		if (tree_prop[i].y == tree_prop[a].y && tree_prop[i].x > tree_prop[a].x) {
			min = i;
			break;
		}
	}
	for (int j=i+1; j<no_of_trees; j++) {
		if (tree_prop[j].y == tree_prop[a].y && tree_prop[j].x > tree_prop[a].x && tree_prop[j].x < tree_prop[min].x) {
			min = j;
		}
	}
	if (min >0) {
		if (tree_prop[a].weight > tree_prop[min].weight && tree_prop[a].h > tree_prop[min].x-tree_prop[a].x) {
			profit= v[min].value;
      temp[iterator]=min;
      iterator++;
			int temp1= cutright_profit(min);
			profit= profit + temp1;
			return profit;
		}
		else {
			return 0;
		}
	}
	else {
		return 0;
	}
}
